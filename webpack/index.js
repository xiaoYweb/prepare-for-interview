/**
 * webpack 原理
 * webpack 最初是js的模块打包工具 之后逐步支持其他类型文件的打包输出
 * 1. 初始化参数 从配置文件和 Shell 脚本命令中读取、合并参数 
 * 2. 根据参数 初始化 Compiler 对象 加载所有配置的插件，执行对象的 run 方法开始执行编译
 * 3. 根据配置中的 entry 找出所有的入口文件 调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，递归操作此步骤
 * 4. 完成模块编译 得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
 * 5. 输出资源 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，(这步是可以修改输出内容的最后机会)  
 * 6. 输出完成 确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
 */

/**
 * import 和 require 的区别
 * require 
 * 1. require是commonjs规范 
 * 2. 运行时执行： 加载模块时  会运行整个模块的代码 
 * 3. 同一个模块在同一个文件中可以多次导入 第一次加载模块时 会被缓存  后面加载 不会执行模块内部代码 直接走缓结果  
 * 4. 导入时是值得拷贝 类似赋值操作 基础类型的赋值修改不影响 另一模块内的变量 对象类型的属性修改 会影响到模块内部的变量值
 * 5. 由于导入导出是运行时赋值的 循环引用下存在 取不到值的可能 
 * 
 * import
 * 1. import 是 ES6 模块导入、导出规范
 * 2. 编译时执行：import 导入模块时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值
 * 3. 同一个模块在同一个文件中只允许导入一次 
 * 4. 导入时是值的引用 只读不允许修改 
 * 5. 导入导出是编译时赋值的 值得引用 循环引用下 代码先后导入导出 不影响代码运行
 */

/**
 * webpack Plugin 和 Loader 的区别
 * 
  用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 buld 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等。

  目的在于解决 loader 无法实现的其他事,它直接作用于 webpack，扩展了它的功能。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

 */