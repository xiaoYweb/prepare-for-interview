/** middle 数组中重复的数据
 * 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素 ((出现两次)) 而 ((其他元素出现一次))。

  找到所有出现两次的元素。

  你可以 ((不用到任何额外空间)) 并 ((在O(n)时间复杂度内)) 解决这个问题吗？

  提示:  
  1 ≤ a[i] ≤ n 
  元素最多出现2次

  输入:
  [4,3,2,7,8,2,3,1]

  输出:
  [2,3]
 */

/**
 * 与对应位置的值交换位置 
 * [4,3,2,7,8,2,3,1]
 * 0 - 4  ->   3 - 7 [7,3,2,4,8,2,3,1]
 * 0 - 7  ->   6 - 3 [3,3,2,4,8,2,7,1]
 * 0 - 3  ->   2 - 2 [2,3,3,4,8,2,7,1]
 * 0 - 2  ->   1 - 3 [3,2,3,4,8,2,7,1]
 * 0 - 3  ->   2 - 3 [3,2,3,4,8,2,7,1]  不变 索引往后 
 * 1 - 2  ->   1 - 2 [3,2,3,4,8,2,7,1]  不变 索引往后
 * 2 - 3  ->   2 - 3 [3,2,3,4,8,2,7,1]  不变 索引往后
 * 3 - 4  ->   2 - 3 [3,2,3,4,8,2,7,1]  不变 索引往后
 * 4 - 8  ->   7 - 1 [3,2,3,4,1,2,7,8]  
 * 4 - 1  ->   0 - 3 [1,2,3,4,3,2,7,8]  
 * 4 - 3  ->   2 - 3 [1,2,3,4,3,2,7,8]   不变 索引往后
 * 5 - 2  ->   1 - 2 [1,2,3,4,3,2,7,8]   不变 索引往后
 * 6 - 7  ->   6 - 7 [1,2,3,4,3,2,7,8]   不变 索引往后
 * 7 - 8  ->   6 - 7 [1,2,3,4,3,2,7,8]   不变 索引往后
 */
console.log('-', findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]))
function findDuplicates(nums) { // nums[i] 范围 1 ~ n  前提 元素最多出现2次
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    const other = nums[num - 1]
    if (num !== other) { // [4,3,2,7,8,2,3,1]    
      [nums[i], nums[num - 1]] = [other, num]
      i--
    }
  }
  return nums.filter((num, i) => num !== i + 1)
}

// 延伸思考  若 出现次数可以多次  那么 可以 在可以被[num-1]整除 ? 对应位置 += : 交换位置 索引 --

/**
 * [2,2,2,3]
 * 0 - 2  ->  1 - 2 []
 * 
 */